import { initializeApp } from 'firebase/app';
import { getFirestore, collection, getDocs } from "firebase/firestore";
import { getAuth, onAuthStateChanged } from 'firebase/auth';
import { fbConfigStuff } from './config.js';

// firebase shit
let fbConfig = fbConfigStuff();
let app = initializeApp(fbConfig);
let db = getFirestore(app);
let auth = getAuth();

// grab DOM elements
let mainElement = document.querySelector('.statistics');
let courseItemsSection = document.querySelector('.courses');
// course data modal
let courseDiv = document.querySelector('.course');
let courseDivHeader = document.querySelector('.course-header');
let courseDivChart = document.querySelector('.course-chart');
let closeCourseModal = document.querySelector('.course-close');
// holes data modal
let holesDiv = document.querySelector('.holes');
let holesDivHeader = document.querySelector('.holes-header');
let holesDivChart = document.querySelector('.holes-chart');
let closeHolesModal = document.querySelector('.holes-close');

// initialize
let fbUserID;
let roundsData = [];
let warningOutput = "";
let deduped;
let chosenCourseID = '';
let buttonChoice = '';
let chosenCourseRounds = [];
let chosenCourseName = '';
let overAllScore = [];
let minMaxAvgScore = [];
let playerScoring = [];
let holeThrowsArray;
let minMaxAvgHole = [];
let holeIDArray = [];
let newData = [];


(() => {
  'use strict';

  let stats = {

    init() {
      onAuthStateChanged(auth, async (user) => {
        fbUserID = user.uid;

        let roundsQuery = await getDocs(collection(db, 'players', fbUserID, 'savedRounds'));

        // this both converts firestore data to an in-house js object
        // and gets rid of any dummy documents generated by firestore
        roundsQuery.forEach((doc) => {
          if (Object.keys(doc.data()).length > 0) {
            // console.log(doc.id);
            roundsData.push(doc.data());
          }
        });
        console.log(roundsData);

        if (roundsData.length > 0) {
          stats.buildListForDOM(roundsData);
        } else {
          stats.noRounds(roundsData);
        }
      }); // end onAuthStateChanged()
    }, // end init()

    noRounds(roundsData) {

      // remove section where course cards to choose are displayed since there are no rounds
      courseItemsSection.remove();

      warningOutput += `
        <p class="warning">You don't have any rounds saved yet,</p>
        <a href="/pages/roundsetup.html" class="warning-link">Go ahead and start one!  âž¤</a>
      `;
      mainElement.innerHTML += warningOutput;
    }, // end noRounds()

    buildListForDOM(roundsData) {

      // remove duplicates for on-screen display
      deduped = roundsData.filter((obj, index) => {
        return index === roundsData.findIndex(o => obj.courseID === o.courseID);
      });

      // then present on-screen
      courseItemsSection.innerHTML = '';
      deduped.forEach((round) => {
        courseItemsSection.innerHTML += `
          <div class="course-card">
            <p>${round.courseName}</p>
            <button class="course-card-button" data-choice="course" data-courseid="${round.courseID}">Course Stats</button>
            <button class="course-card-button" data-choice="holes" data-courseid="${round.courseID}">Hole Stats</button>
          </div>
        `;
      });

      stats.manageDOMList(roundsData);
    }, // end buildListForDOM()

    manageDOMList(roundsData) {

      courseItemsSection.addEventListener('click', (event) => {

        // which button was clicked
        chosenCourseID = event.target.closest('.course-card-button').dataset.courseid;
        buttonChoice = event.target.closest('.course-card-button').dataset.choice;

        // get the appropriate rounds
        chosenCourseRounds = roundsData.filter((round) => {return round.courseID == chosenCourseID});

        switch (buttonChoice) {
          case 'course':
            stats.buildCourseData(chosenCourseRounds);            
          break;
          case 'holes':
            stats.buildHoleData(chosenCourseRounds);            
          break;
        
          default:
            break;
        };
      });      
    }, // end manageDOMList()

    buildCourseData(chosenCourseRounds) {

      // set course name for modal
      chosenCourseName = chosenCourseRounds[0].courseName;

      for (let i = 0; i < chosenCourseRounds.length; i++) {
        // for now, there's only one player
        overAllScore.push(chosenCourseRounds[i].player.finalScore);        
      };

      // build the min-max-avg for the overall course score
      let bestScore = Math.min(...overAllScore);
      let worstScore = Math.max(...overAllScore);
      let averageScore = overAllScore.reduce((a,b) => a + b) / overAllScore.length;
      // round down to nearest integer
      let gridAverageScore = Math.floor(Number(averageScore));
      // restrict to one decimal place
      let realAverageScore = parseFloat(averageScore.toFixed(1));
      
      // minMaxAvgScore.push({minimum: bestScore, maximum: worstScore, gridaverage: gridAverageScore, realavg: realAverageScore});
      minMaxAvgScore.push(bestScore, worstScore, realAverageScore);

      stats.buildCourseGraph(chosenCourseName, minMaxAvgScore);
    }, // end buildCourseData()

    buildCourseGraph(chosenCourseName, minMaxAvgScore) {

      courseDivHeader.innerHTML = `<p class="course-header-text">${chosenCourseName}</p><p>Overall Course Performance</p>`;

      // courseDivChart.innerHTML = `
      //   <p style="grid-column-end: span ${minMaxAvgScore[0].minimum}">
      //     Best: <span>${minMaxAvgScore[0].minimum}</span>
      //   </p>
      //   <p style="grid-column-end: span ${minMaxAvgScore[0].maximum}">
      //     Worst: <span>${minMaxAvgScore[0].maximum}</span>
      //   </p>
      //   <p style="grid-column-end: span ${minMaxAvgScore[0].gridaverage}">
      //     Average: <span>${minMaxAvgScore[0].realavg}</span>
      //   </p>
      // `;

      new Chart(
        document.getElementById('courseChart'),
        {
          plugins: [ChartDataLabels],
          type: 'bar',
          options: {
            indexAxis: 'y',
            elements: {
              bar: {
                backgroundColor: 'rgba(101, 109, 154, 0.5)',
                borderWidth: 1,
                borderRadius: 8,
                borderColor: 'rgb(101, 109, 154)'
              }
            },
            plugins: {
              title: {
                display: false,
              },
              legend: {
                display: false
              },
              datalabels: {
                font: {
                  size: 24,
                  weight: 'bold'
                }
              }
            }
          },
          data: {
            labels: ['Best', 'Worst', 'Average'],
            datasets: [
              {
                data: minMaxAvgScore
              }
            ],
          },
        }
      );

      courseDiv.showModal();

      closeCourseModal.addEventListener('click', (event) => {

        courseDiv.close();

        //clean out all the things
        courseDivChart.innerHTML = '<canvas id="courseChart" style="height: 45vh"></canvas>';
        overAllScore.splice(0, overAllScore.length);
        minMaxAvgScore.splice(0, minMaxAvgScore.length);
      }); // end addEventListener()
    }, // end buildCourseGraph()

    buildHoleData(chosenCourseRounds) {

      // setting to be length of course
      holeThrowsArray = Array(chosenCourseRounds[0].player.courseHoles.length).fill(0).map(() => []);

      chosenCourseName = chosenCourseRounds[0].courseName;

      for (let i = 0; i < chosenCourseRounds.length; i++) {
        playerScoring.push(chosenCourseRounds[i].player.courseHoles);
      };

      for (let i = 0; i < playerScoring.length; i++) {
        for (let j = 0; j < holeThrowsArray.length; j++) {
          holeThrowsArray[j].push(playerScoring[i][j].throwsHole);
        };
      };

      // build the min-max-avg for each hole
      for (let i = 0; i < holeThrowsArray.length; i++) {
        // first the math
        let minNumber = Math.min(...holeThrowsArray[i]);
        let maxNumber = Math.max(...holeThrowsArray[i]);
        let avgNumber = holeThrowsArray[i].reduce((a,b) => a + b) / holeThrowsArray[i].length;
        // round down to nearest integer, i.e. no decimals
        let gridAvgNumber = Math.floor(Number(avgNumber));
        // restrict to one decimal place
        let realAvg = parseFloat(avgNumber.toFixed(1));
        // hole number as string
        let hn = i + 1;
        let holeNumber = 'Hole ' + hn.toString();

        minMaxAvgHole.push({hole: holeNumber, minimum: minNumber, maximum: maxNumber, gridaverage: gridAvgNumber, realavg: realAvg});
      };

      // need to get the holePar into minMaxAvgHole for display purposes
      for (let i = 0; i < playerScoring.length; i++) {
        for (let j = 0; j < minMaxAvgHole.length; j++) {
          minMaxAvgHole[j].par = playerScoring[i][j].holePar;
        };
      };
    
      stats.buildHoleGraph(chosenCourseName, minMaxAvgHole)
    }, // end buildHoleData()

    buildHoleGraph(chosenCourseName, minMaxAvgHole) {
      console.log('hole data:', minMaxAvgHole);

      holesDivHeader.innerHTML = `<p class="holes-header-text">${chosenCourseName}</p><p>Hole-By-Hole</p>`;

      // https://joshcollinsworth.com/blog/css-grid-bar-charts
      // minMaxAvgHole.forEach((hole) => {
      //   holesDivChart.innerHTML += `
      //     <div class="holes-chart-hole">
      //       <h4 class="holes-chart-hole-name" style="grid-column: span ${hole.maximum}">
      //         ${hole.hole} 
      //         <span class="holes-chart-hole-name-par">Par: ${hole.par}</span>
      //       </h4>
      //       <p style="grid-column-end: span ${hole.minimum}">
      //         Best: <span>${hole.minimum}</span>
      //       </p>
      //       <p style="grid-column-end: span ${hole.maximum}">
      //         Worst: <span>${hole.maximum}</span>
      //       </p>
      //       <p style="grid-column-end: span ${hole.gridaverage}">
      //         Average: <span>${hole.realavg}</span>
      //       </p>
      //     </div>
      //   `;
      // });


      minMaxAvgHole.forEach((hole, index) => {
        // create the hole id selector for chart.js to grab
        let holeID = `hole${index + 1}`;
        holeIDArray.push(holeID);

        holesDivChart.innerHTML += `
          <div class="holes-chart-hole">
            <h4 class="holes-chart-hole-name">
              ${hole.hole} 
              <span class="holes-chart-hole-name-par">Par: ${hole.par}</span>
            </h4>
            <canvas id=${holeID}></canvas>
          </div>
        `;
      }); // end forEach()

      // new array to play nice with chart.js, just three numbers in an array inside an array
      for (let i = 0; i < minMaxAvgHole.length; i++) {
        let insideNewData = [];
        insideNewData.push(minMaxAvgHole[i].minimum, minMaxAvgHole[i].maximum, minMaxAvgHole[i].realavg);
        newData.push(insideNewData);
      };

      Chart.defaults.font.weight = 'bold';
      // create a chart for each hole div in the dialog
      for (let i = 0; i < holeIDArray.length; i++) {
        new Chart(
          document.getElementById(holeIDArray[i]),
          {
            plugins: [ChartDataLabels],
            type: 'bar',
            options: {
              indexAxis: 'y',
              elements: {
                bar: {
                  backgroundColor: 'rgba(101, 109, 154, 0.5)',
                  borderWidth: 1,
                  borderRadius: 8,
                  borderColor: 'rgb(101, 109, 154)'
                }
              },
              plugins: {
                title: {
                  display: false,
                },
                legend: {
                  display: false
                },
                datalabels: {
                  font: {
                    size: 24,
                    weight: 'bold'
                  }
                }
              }
            },
            data: {
              labels: ['Best', 'Worst', 'Average'],
              datasets: [
                {
                  data: newData[i]
                }
              ],
            },
          }
        ); // end Chart()
      }; // end for loop

      holesDiv.showModal();

      closeHolesModal.addEventListener('click', (event) => {

        holesDiv.close();

        holeIDArray = [];
        holesDivChart.innerHTML = '';
        playerScoring.splice(0, playerScoring.length);
        holeThrowsArray.splice(0,holeThrowsArray.length);
        minMaxAvgHole.splice(0, minMaxAvgHole.length);
      
      }); // end addEventListener()
    }, // end buildHoleGraph()
  };
  stats.init();
})();